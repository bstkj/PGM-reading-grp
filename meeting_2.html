<!DOCTYPE html>
<html>
<head>
  <title>PGMs – An Odyssey</title>

  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="chrome=1">
  <meta name="generator" content="pandoc" />




  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="apple-mobile-web-app-capable" content="yes">

  <base target="_blank">

  <script type="text/javascript">
    var SLIDE_CONFIG = {
      // Slide settings
      settings: {
                title: 'PGMs – An Odyssey',
                        subtitle: 'Book 2: Exact inference with Clique Trees',
                useBuilds: true,
        usePrettify: true,
        enableSlideAreas: true,
        enableTouch: true,
                      },

      // Author information
      presenters: [
            {
        name:  'Ben Teo' ,
        company: '',
        gplus: '',
        twitter: '',
        www: '',
        github: ''
      },
            ]
    };
  </script>

  <script src="meeting_2_files/header-attrs-2.14/header-attrs.js"></script>
  <link href="meeting_2_files/ioslides-13.5.1/fonts/fonts.css" rel="stylesheet" />
  <link href="meeting_2_files/ioslides-13.5.1/theme/css/default.css" rel="stylesheet" />
  <link href="meeting_2_files/ioslides-13.5.1/theme/css/phone.css" rel="stylesheet" />
  <script src="meeting_2_files/ioslides-13.5.1/js/modernizr.custom.45394.js"></script>
  <script src="meeting_2_files/ioslides-13.5.1/js/prettify/prettify.js"></script>
  <script src="meeting_2_files/ioslides-13.5.1/js/prettify/lang-r.js"></script>
  <script src="meeting_2_files/ioslides-13.5.1/js/prettify/lang-yaml.js"></script>
  <script src="meeting_2_files/ioslides-13.5.1/js/hammer.js"></script>
  <script src="meeting_2_files/ioslides-13.5.1/js/slide-controller.js"></script>
  <script src="meeting_2_files/ioslides-13.5.1/js/slide-deck.js"></script>

  <style type="text/css">

    b, strong {
      font-weight: bold;
    }

    em {
      font-style: italic;
    }

    summary {
      display: list-item;
    }

    details > summary > p:only-child {
      display: inline;
    }

    slides > slide {
      -webkit-transition: all 0.4s ease-in-out;
      -moz-transition: all 0.4s ease-in-out;
      -o-transition: all 0.4s ease-in-out;
      transition: all 0.4s ease-in-out;
    }

    .auto-fadein {
      -webkit-transition: opacity 0.6s ease-in;
      -webkit-transition-delay: 0.4s;
      -moz-transition: opacity 0.6s ease-in 0.4s;
      -o-transition: opacity 0.6s ease-in 0.4s;
      transition: opacity 0.6s ease-in 0.4s;
      opacity: 0;
    }
/* https://github.com/ropensci/plotly/pull/524#issuecomment-468142578 */
slide:not(.current) .plotly.html-widget{
  display: block;
}

    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
            
  </style>

  <link rel="stylesheet" href="styles.css" type="text/css" />

</head>

<body style="opacity: 0">

<slides>

  <slide class="title-slide segue nobackground">
        <!-- The content of this hgroup is replaced programmatically through the slide_config.json. -->
    <hgroup class="auto-fadein">
      <h1 data-config-title><!-- populated from slide_config.json --></h1>
      <h2 data-config-subtitle><!-- populated from slide_config.json --></h2>
      <p data-config-presenter><!-- populated from slide_config.json --></p>
            <p style="margin-top: 6px; margin-left: -2px;">5/2/2022</p>
          </hgroup>
  </slide>

<p>\(\newcommand{\indep}{\perp\!\!\!\perp}\) \(\newcommand{\QED}{\scriptsize{\square}}\)</p>

<slide class=""><hgroup><h2></h2></hgroup><article >

<p><font size="5"></p>

<blockquote>

The basic operation of the VE algorithm is the manipulation of factors.

</blockquote>

<ul>
<li>Each step consumes existing factors to generate a new factor.</li>
</ul>

<blockquote>

We consider a factor \(\psi_i\) to be a <em>computational data structure</em>, which takes <em>&ldquo;messages&rdquo;</em> \(\tau_j\) generated by other factors \(\psi_j\), and generates a message \(\tau_i\) that is used by another factor \(\psi_l\).

</blockquote>

<ul>
<li>Data structures implement abstract data types (ADTs).</li>
<li>E.g. Factors represented as arrays. Marginalization and multiplication of factors/arrays defined.</li>
</ul>

<p></font></p>

</article></slide><slide class=""><hgroup><h2>Cluster graph</h2></hgroup><article  id="cluster-graph">

<p><font size="5"></p>

<blockquote>

A data structure that provides a graphical flowchart of the factor-manipulation process.

</blockquote>

<p><def> Cluster graph \(\mathcal{U}\) for set of factors \(\Phi\) over \(\mathcal{X}\) is an undirected graph, each of whose nodes \(i\) is a cluster \(\mathbf{C}_i\subseteq\mathcal{X}\).</p>

<ul>
<li>\(\mathcal{U}\) must be <em>family-preserving</em>: For each \(\phi\in\Phi\), there must exist \(\mathbf{C}_i\) such that \(\alpha(\phi)\equiv\text{Scope}[\phi] \subseteq\mathbf{C}_i\)</li>
<li>Each edge \(\mathbf{C}_i-\mathbf{C}_j\) is associated with a sepset \(\mathbf{S}_{i,j}\subseteq\mathbf{C}_i\cap \mathbf{C}_j\). </def></li>
</ul>

<p></font></p>

</article></slide><slide class=""><hgroup><h2>Cluster graph for VE</h2></hgroup><article  id="cluster-graph-for-ve">

<p><font size="5"></p>

<p>The cluster graph induced by <em>Variable Elimination</em> (VE) is a tree.</p>

<ul>
<li>Let the \(\psi\)s denote factors to be marginalized (e.g. each \(\psi\) is a product of initial factors \(\phi\)s multiplied by intermediate factors, \(\tau\)s).</li>
<li>The \(\psi\)s are marginalized to produce \(\tau\)s, which are sent to products of \(\phi\)s.</li>
</ul>

<p><pf> Given an elimination ordering \((X_1,\ldots,X_n)\):</p>

<ol>
<li>Order the \(\psi\)s so that the \(\psi\) where \(X_i\) is marginalized out is denoted by \(\psi_i\), and the resultant factor by \(\tau_i\).</li>
<li>Let \(\mathbf{C}_i=\text{Scope}[\psi_i]\in\mathcal{V}_\mathcal{U}\). Let \(\mathbf{C}_i\rightarrow\mathbf{C}_{j}\in\mathcal{E}_\mathcal{U}\) if \(\psi_i\) is used to compute \(\psi_j\) through \(\tau_i\) (\(\Rightarrow \mathbf{C}_i\cap\mathbf{C}_j\neq\emptyset\)).</li>
</ol>

<p>The \(\mathbf{C}_i\)s are topologically ordered, so there are no cycles in \(\mathcal{U}\) \(\QED\) </pf></p>

<p></font></p>

</article></slide><slide class=""><hgroup><h2>Cluster tree</h2></hgroup><article  id="cluster-tree">

<p><font size="5"></p>

<p>Let \(\mathcal{T}=(\mathcal{V}_\mathcal{T},\mathcal{E}_\mathcal{T})\) be a cluster tree (over a set of factors \(\Phi\)).</p>

<p><def> \(\mathcal{T}\) has the <em>running intersection property</em> if whenever \(X\in \mathbf{C}_i\) and \(X\in \mathbf{C}_j\), then \(X\) is also in every cluster in the (unique) path between \(\mathbf{C}_i\) and \(\mathbf{C}_j\) in \(\mathcal{T}\). </def></p>

<p>By construction, a cluster tree \(\mathcal{T}\) induced by VE satisfies:</p>

<ul>
<li>Running intersection property.</li>
<li>If \(C_i-C_j\in\mathcal{E}_\mathcal{T}\) (i.e. \(\mathbf{C}_i\) passes message \(\tau_i\) to \(\mathbf{C}_j\)), then \(\text{Scope}[\tau_i]=\mathbf{C}_i\cap \mathbf{C}_j\).</li>
</ul>

<p></font></p>

</article></slide><slide class=""><hgroup><h2>Clique tree</h2></hgroup><article  id="clique-tree">

<p><font size="5"></p>

<p><def> A cluster tree \(\mathcal{T}\) that satisfies the running intersection property is called a clique tree (or junction tree or join tree). </def></p>

<p>Let \(\mathcal{T}\) and \(\mathcal{H}\) respectively be a cluster tree and an undirected graph associated with \(\Phi\).</p>

<p><thm> \(\mathcal{T}\) is a clique tree iff it is a clique tree for a chordal graph containing \(\mathcal{H}\). </thm></p>

<ul>
<li>The key to understanding this equivalence goes back to viewing the cluster graph as <strong>a data structure that provides a graphical flowchart of the factor-manipulation process</strong>.</li>
</ul>

<p></font></p>

</article></slide><slide class=""><hgroup><h2>Clique tree: intuition</h2></hgroup><article  id="clique-tree-intuition">

<p><font size="5"></p>

<p>Let \(\mathcal{H}_\Phi\) be <strong>the</strong> minimal I-map for \(P_\Phi\), and \(\prec\) some VE ordering.</p>

<ul>
<li>The induced graph \(\mathcal{I}_{\Phi,\prec}\) contains \(\mathcal{H}_\Phi\) and is chordal.</li>
<li>The maximal cliques in \(\mathcal{I}_{\Phi,\prec}\) correspond to the clusters in \(\mathcal{T}_{\Phi,\prec}\).</li>
<li>A sequence of VE steps can be represented by a sequence of graph transformations applied to starting point \(\mathcal{H}_\Phi\).</li>
<li>By construction, \(S_{i,j}\) as defined for \(\mathcal{T}_{\Phi,\prec}\) separates \(\mathbf{W}_{&lt;(i,j)}\) and \(\mathbf{W}_{&lt;(j,i)}\) in \(\mathcal{I}_{\Phi,\prec}\).</li>
</ul>

<p></font></p>

</article></slide><slide class=""><hgroup><h2>Sum-product (SP) message passing</h2></hgroup><article  id="sum-product-sp-message-passing">

<p><font size="5"></p>

<p>Each clique, \(\mathbf{C}_i\)</p>

<ol>
<li><em>Collects</em> messages/factors, \(\delta_{k\rightarrow i}\)</li>
<li><em>Multiplies</em> them with its initial potential, \(\psi_i\)</li>
<li><em>Sums out</em> one or more variables, \(\mathbf{C}_i\setminus\mathbf{S}_{i,j}\)</li>
<li><em>Sends</em> this message/factor, \(\delta_{i\rightarrow j}\) to another clique</li>
</ol>

<p>\[\delta_{i\rightarrow j}=\sum_{\mathbf{C}_i\setminus\mathbf{S}_{i,j}}
\psi_i\cdot\prod_{k\in\text{Nb}_i\setminus\{j\}}\delta_{k\rightarrow i}\]</p>

<p>For root clique \(\mathbf{C}_r\), its <em>beliefs</em> is the factor defined by \[\beta_r(\mathbf{C}_r)=\psi_r\cdot\prod_{k\in\text{Nb}_r}
\delta_{k\rightarrow r}\]</p>

<p></font></p>

</article></slide><slide class=""><hgroup><h2>SP message passing: Correctness</h2></hgroup><article  id="sp-message-passing-correctness">

<p><font size="5"></p>

<p>Let \(\mathcal{T}\) be a clique tree that satisfies the family-preservation and running intersection property.</p>

<p><prp> If \(X\) is eliminated when a message is sent from \(\mathbf{C}_i\) to \(\mathbf{C}_j\), then \(X\) does not appear anywhere in the tree on the \(\mathbf{C}_j\) side of the edge \((i-j)\). </prp></p>

<p><thm> Let \(\delta_{i\rightarrow j}\) be a message from \(\mathbf{C}_i\) to \(\mathbf{C}_j\). Then \[\delta_{i\rightarrow j}(\mathbf{S}_{i,j})=
\sum_{\mathcal{V}_{\prec (i\rightarrow j)}}
\prod_{\phi\in\mathcal{F}_{\prec (i\rightarrow j)}}\phi\] </thm> where \(\mathcal{F}_{\prec (i\rightarrow j)}\) is the set of factors in cliques on the \(\mathbf{C}_i\)-side of an edge, and \(\mathcal{V}_{\prec (i\rightarrow j)}\) is the set of variables that appear on the \(\mathbf{C}_i\)-side but are not in \(\mathbf{S}_{i,j}\).</p>

<ul>
<li>\(\beta_r(\mathbf{C}_r)=\sum_{\mathcal{X}\setminus\mathbf{C}_r} \tilde{P}_\Phi(\mathcal{X})=\tilde{P}_\Phi(\mathbf{C}_r)\)</li>
</ul>

<p></font></p>

</article></slide><slide class=""><hgroup><h2>SP message passing: Applicability</h2></hgroup><article  id="sp-message-passing-applicability">

<p><font size="5"></p>

<p>SP message passing on a clique tree can be used to do VE on both BNs and MNs.</p>

<ul>
<li>Let \(\Phi\) respectively be the set of CPDs for BNs, and the set of compatibility functions for MNs.</li>
</ul>

<p></font></p>

</article></slide><slide class=""><hgroup><h2>SP belief propagation (BP)</h2></hgroup><article  id="sp-belief-propagation-bp">

<p><font size="5"></p>

<p>SP BP: Pass messages (asynchronously) until each \(\mathbf{C}_i\) has received a message from each neighboring \(\mathbf{C}_k\).</p>

<p><def> Two adjacent cliques \(\mathbf{C}_i\) and \(\mathbf{C}_j\) are calibrated if \[\sum_{\mathbf{C}_i\setminus\mathbf{S}_{i,j}}\beta_i(\mathbf{C}_i)=
\sum_{\mathbf{C}_j\setminus\mathbf{S}_{i,j}}\beta_j(\mathbf{C}_j)\] </def></p>

<ul>
<li>Clique tree \(\mathcal{T}\) is calibrated if all pairs of adjacent cliques are calibrated.</li>
<li>If \(\mathcal{T}\) is calibrated, we refer to \(\beta_i(\mathbf{C}_i)\) as <em>clique beliefs</em> and \(\mu_{i,j}(\mathbf{S}_{i,j})= \sum_{\mathbf{C}_i\setminus\mathbf{S}_{i,j}}\beta_i(\mathbf{C}_i)= \sum_{\mathbf{C}_j\setminus\mathbf{S}_{i,j}}\beta_j(\mathbf{C}_j)\) as <em>sepset beliefs</em>.</li>
<li>SP BP terminates \(\Rightarrow\) \(\mathcal{T}\) is calibrated.</li>
</ul>

<p></font></p>

</article></slide><slide class=""><hgroup><h2>Calibrated clique trees</h2></hgroup><article  id="calibrated-clique-trees">

<p>At calibration</p>

<p>\[\begin{equation*}
\begin{split}
\beta_i &amp;= \psi_i\cdot\prod_{k\in\text{Nb}_i}\delta_{k\rightarrow i} \\
\mu_{i,j} &amp;= \delta_{j\rightarrow i}\delta_{i\rightarrow j}
\end{split}
\end{equation*}\]</p>

<p><prp> At convergence of SP BP, we have that \[\tilde{P}_\Phi(\mathcal{X})=
\frac{\prod_{i\in\mathcal{V}_\mathcal{T}}\beta_i(\mathbf{C}_i)}{
\prod_{(i-j)\in\mathcal{E}_\mathcal{T}}\mu_{i,j}(\mathbf{S}_{i,j})}\] </prp> \(\tilde{P}_\Phi(\mathcal{X})\) reparameterized in terms of the \(\beta_i\)s and \(\mu_{i,j}\)s (i.e. clique and sepset beliefs, or the clique marginals).</p>

</article></slide><slide class=""><hgroup><h2>Calibrated clique trees</h2></hgroup><article  id="calibrated-clique-trees-1">

<p><font size="5"></p>

<p><def> The <em>measure induced by a calibrated tree</em> \(\mathcal{T}\) is \[\mathcal{Q}_\mathcal{T}=
\frac{\prod_{i\in\mathcal{V}_\mathcal{T}}\beta_i(\mathbf{C}_i)}{
\prod_{(i-j)\in\mathcal{E}_\mathcal{T}}\mu_{i,j}(\mathbf{S}_{i,j})}\] </def></p>

<p>For a set of calibrated potentials derived from SP BP, the following hold</p>

<ul>
<li>\(\mathcal{Q}_\mathcal{T}=\tilde{P}_\Phi(\mathcal{X})\)</li>
<li>\(\beta_i(\mathbf{C}_i)=\sum_{\mathcal{X}\setminus\mathbf{C}_i} \tilde{P}_\Phi(\mathcal{X})=\tilde{P}_\Phi(\mathbf{C}_i)\)</li>
</ul>

<p><thm> Let \(\beta_i\) be a set of calibrated potentials for clique tree \(\mathcal{T}\). \(\tilde{P}_\Phi(\mathcal{X})\propto\mathcal{Q}_\mathcal{T}\) iff for each \(i\in\mathcal{V}_\mathcal{T}\), \(\beta_i(\mathbf{C}_i)\propto\tilde{P}_\Phi(\mathbf{C}_i)\). </thm></p>

<p></font></p>

</article></slide><slide class=""><hgroup><h2>Belief-update (BU) message passing</h2></hgroup><article  id="belief-update-bu-message-passing">

<p><font size="5"></p>

<p>Also known as the <em>Lauritzen-Spiegelhalter algorithm</em>.</p>

<p>Each message passing step modifies the \(\beta_i\)s and \(\mu_{i,j}\)s while maintaining \(\mathcal{Q}_\mathcal{T}=\tilde{P}_\Phi(\mathcal{X})\) as an invariant.</p>

<ul>
<li>In addition to the &ldquo;sum&rdquo; and &ldquo;product&rdquo; operations, <em>factor division</em> needs to be defined.</li>
</ul>

<p>In contrast, SP message passing focuses on receiving \(\delta_{k\rightarrow i}\)s and sending \(\delta_{i\rightarrow j}\)s. \(\beta_i\) is computed once all \(\delta_{k\rightarrow i}\)s have been received.</p>

<p></font></p>

</article></slide><slide class=""><hgroup><h2>BU message passing: Steps</h2></hgroup><article  id="bu-message-passing-steps">

<p><font size="5"></p>

<p>Each clique, \(\mathbf{C}_i\)</p>

<ol>
<li><em>Receives</em> message, \(\sigma_{k\rightarrow i}/\mu_{i,k}\) through edge \((i-k)\).</li>
<li><em>Updates</em> its belief \(\beta_i\) by <em>multiplying</em> it with \(\sigma_{k\rightarrow i}/\mu_{i,k}\)</li>
<li><em>Sums</em> out one or more variables, \(\mathbf{C}_i\setminus\mathbf{S}_{i,j}\) from the updated \(\beta_i\)</li>
<li><em>Sends</em> this message, \(\sigma_{i\rightarrow j}\) towards neighbor clique, \(\mathbf{C}_j\)</li>
</ol>

<p>Each edge, \((i-j)\)</p>

<ol>
<li><em>Divides</em> a message, \(\sigma_{i\rightarrow j}\) that crosses it by its belief, \(\mu_{i,j}\). \(\sigma_{i\rightarrow j}/\mu_{i,j}\) is sent to the destination clique, \(\mathbf{C}_j\)</li>
<li><em>Updates</em> its belief \(\mu_{i,j}=\sigma_{i\rightarrow j}\)</li>
</ol>

<p>BU MP converges \(\Rightarrow\) \(\mathcal{T}\) is calibrated.</p>

<p></font></p>

</article></slide><slide class=""><hgroup><h2>Equivalence of SP/BU message passing</h2></hgroup><article  id="equivalence-of-spbu-message-passing">

<p><font size="5"></p>

<p><thm> Consider a set of SP initial potentials \(\{\psi_i\mid i\in \mathcal{V}_\mathcal{T}\}\) and messages \(\{\delta_{i\rightarrow j}, \delta_{j\rightarrow i}\mid (i-j)\in\mathcal{E}_\mathcal{T}\}\), and a set of BU beliefs \(\{\beta_i\mid i\in\mathcal{V}_\mathcal{T}\}\) and messages \(\{\mu_{i,j}\mid (i-j)\in\mathcal{E}_\mathcal{T}\}\). Suppose equations \[\begin{equation*}
\begin{split}
\beta_i &amp;= \psi_i\prod_{k\in\text{Nb}_i}\delta_{k\rightarrow i} \\
\mu_{i,j} &amp;= \delta_{j\rightarrow i}\delta_{i\rightarrow j}
\end{split}
\end{equation*}\] hold. Then for any \((i-j)\in\mathcal{T}\), the updated SP messages after an application of \(\text{SP-Message}(i,j)\) and the updated BU beliefs after an application of \(\text{BU-Message}(i,j)\) continue to satisfy these equations. </thm></p>

<ul>
<li>We do not assume \(\delta_{i\rightarrow j}=\sum_{\mathbf{C}_i\setminus \mathbf{S}_{i,j}}\psi_i\prod_{k\in\text{Nb}_i\setminus\{j\}} \delta_{k\rightarrow i}\), or anything specific about how the initial messages were computed!</li>
</ul>

<p></font></p>

</article></slide><slide class=""><hgroup><h2>Equivalence of SP/BU MP: Implications</h2></hgroup><article  id="equivalence-of-spbu-mp-implications">

<p><font size="5"></p>

<p><cor> The clique tree invariant (i.e. \(\mathcal{Q}_\mathcal{T}=\tilde{P}_\Phi(\mathcal{X})\)) holds initially for BU MP, and for each subsequent MP step. </cor></p>

<ul>
<li>If clique/sepset beliefs can be factorized according to the two equations on the previous slide, then \(\mathcal{Q}_\mathcal{T}= \tilde{P}_\Phi(\mathcal{X})\) holds.</li>
<li>After each BU step, the updated beliefs can be factorized accordingly.</li>
<li>Since the initial beliefs can also be factorized accordingly, the invariant must hold throughout the algorithm’s run.</li>
</ul>

<p></font></p>

</article></slide><slide class=""><hgroup><h2>Constructing a clique tree</h2></hgroup><article  id="constructing-a-clique-tree">

<p><font size="5"></p>

<ol>
<li>An execution of VE can be associated with a clique tree (i.e. cluster tree + running intersection property).</li>
</ol>

<p><cor> Let \(\mathcal{T}\) be a clique tree induced by VE using ordering \(\prec\). \(\mathbf{C}_i\in\mathcal{V}_\mathcal{T}\) iff \(\mathbf{C}_i\) is a clique in the induced graph \(\mathcal{I}_{\Phi,\prec}\). </cor></p>

<ul>
<li>This motivates the term <em>clique</em> tree.</li>
<li>It is standard to reduce \(\mathcal{T}\) so that each \(\mathbf{C}_i\in \mathcal{V}_\mathcal{T}\) is a maximal clique in \(\mathcal{I}_{\Phi,\prec}\).</li>
</ul>

<p><thm> Let \(\mathcal{T}\) be a clique tree induced by VE using ordering \(\prec\). There exists a clique tree \(\mathcal{T}&#39;\) such that \(\mathcal{V}_\mathcal{T}&#39;\subseteq \mathcal{V}_\mathcal{T}\) and every \(\mathcal{V}_\mathcal{T}&#39;\) is the set of maximal cliques in \(\mathcal{I}_{\Phi,\prec}\). </thm></p>

<p></font></p>

</article></slide><slide class=""><hgroup><h2>Constructing a clique tree</h2></hgroup><article  id="constructing-a-clique-tree-1">

<p><font size="5"></p>

<p>Every chordal graph has a clique tree, and any clique tree can be used for inference.</p>

<p>\[\Phi\rightarrow\mathcal{H}_\Phi\rightarrow\mathcal{H}^*
\rightarrow\mathcal{T}\]</p>

<p><def> The process of constructing a chordal graph that subsumes an existing graph is called <em>triangulation</em>. </def></p>

<p>Finding a minimum triangulation (i.e. the largest clique in the resulting chordal graph has minimum size) is \(\mathcal{NP}\)-hard.</p>

<p>Finding the maximal cliques in a graph is \(\mathcal{NP}\)-hard.</p>

<p>We still need to determine the edges in the clique tree after identifying the maximal cliques.</p>

<p></font></p></article></slide>


  <slide class="backdrop"></slide>

</slides>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "meeting_2_files/mathjax-local/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

<!-- map slide visiblity events into shiny -->
<script>
  (function() {
    if (window.jQuery) {
       window.jQuery(document).on('slideleave', function(e) {
         window.jQuery(e.target).trigger('hidden');
      });
       window.jQuery(document).on('slideenter', function(e) {
         window.jQuery(e.target).trigger('shown');
      });
    }
  })();
</script>

</body>
</html>
