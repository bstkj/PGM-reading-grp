---
title: "PGMs -- An Odyssey"
subtitle: "Book 2: Exact inference with Clique Trees"
author: "Ben Teo"
date: "5/2/2022"
output:
  ioslides_presentation:
    self_contained: false
    mathjax: local
    css: styles.css
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo=F)
```

$\newcommand{\indep}{\perp\!\!\!\perp}$
$\newcommand{\QED}{\scriptsize{\square}}$

---

<font size="5">

<blockquote>
The basic operation of the VE algorithm is the manipulation of factors.
</blockquote>
- Each step consumes existing factors to generate a new factor.

<blockquote>
We consider a factor $\psi_i$ to be a *computational data structure*, which
takes *"messages"* $\tau_j$ generated by other factors $\psi_j$, and generates
a message $\tau_i$ that is used by another factor $\psi_l$.
</blockquote>
- Data structures implement abstract data types (ADTs).
- E.g. Factors represented as arrays. Marginalization and multiplication of
factors/arrays defined.

</font>

## Cluster graph

<font size="5">

<def>
Cluster graph $\mathcal{U}$ for set of factors $\Phi$ over $\mathcal{X}$ is an
undirected graph, each of whose nodes $i$ is a cluster
$\mathbf{C}_i\subseteq\mathcal{X}$.

- $\mathcal{U}$ must be *family-preserving*: For each $\phi\in\Phi$, there must
exist $\mathbf{C}_i$ such that $\alpha(\phi)\equiv\text{Scope}[\phi]
\subseteq\mathbf{C}_i$
- Each edge $\mathbf{C}_i-\mathbf{C}_j$ is associated with a sepset
$\mathbf{S}_{i,j}\subseteq\mathbf{C}_i\cap
\mathbf{C}_j$.
</def>

</font>

## Cluster graph for VE

<font size="5">

The cluster graph induced by *Variable Elimination* (VE) is a tree.

- Let the $\psi$s denote factors to be marginalized (e.g. each $\psi$ is a
product of initial factors $\phi$s multiplied by intermediate factors, $\tau$s).
- The $\psi$s are marginalized to produce $\tau$s, which are sent to products of
$\phi$s.

<pf>
Given an elimination ordering $(X_1,\ldots,X_n)$:

1. Order the $\psi$s so that the $\psi$ where $X_i$ is marginalized out is
denoted by $\psi_i$, and the resultant factor by $\tau_i$.
2. Let $\mathbf{C}_i=\text{Scope}[\psi_i]\in\mathcal{V}_\mathcal{U}$. Let
$\mathbf{C}_i\rightarrow\mathbf{C}_{j}\in\mathcal{E}_\mathcal{U}$ if
$\psi_i$ is used to compute $\psi_j$ through $\tau_i$ ($\Rightarrow
\mathbf{C}_i\cap\mathbf{C}_j\neq\emptyset$).

The $\mathbf{C}_i$s are topologically ordered, so there are no cycles in
$\mathcal{U}$ $\QED$
</pf>

</font>

## Cluster tree

<font size="5">

Let $\mathcal{T}=(\mathcal{V}_\mathcal{T},\mathcal{E}_\mathcal{T})$ be a cluster
tree (over a set of factors $\Phi$).

<def>
$\mathcal{T}$ has the *running intersection property* if whenever
$X\in \mathbf{C}_i$ and $X\in \mathbf{C}_j$, then $X$ is also in every cluster
in the (unique) path between $\mathbf{C}_i$ and $\mathbf{C}_j$ in $\mathcal{T}$.
</def>

By construction, a cluster tree $\mathcal{T}$ induced by VE satisfies:

- Running intersection property.
- If $C_i-C_j\in\mathcal{E}_\mathcal{T}$ (i.e. $\mathbf{C}_i$ passes message
$\tau_i$ to $\mathbf{C}_j$), then $\text{Scope}[\tau_i]=\mathbf{C}_i\cap
\mathbf{C}_j$.

</font>

## Clique tree

<font size="5">

<def>
A cluster tree $\mathcal{T}$ that satisfies the running intersection property is
called a clique tree (or junction tree or join tree).
</def>

Let $\mathcal{T}$ and $\mathcal{H}$ respectively be a cluster tree and an
undirected graph associated with $\Phi$.

<thm>
$\mathcal{T}$ is a clique tree iff it is a clique tree for a chordal graph
containing $\mathcal{H}$.
</thm>

</font>

## Sum-product (SP) message passing

<font size="5">

Each clique, $\mathbf{C}_i$

1. *Collects* messages/factors, $\delta_{k\rightarrow i}$
2. *Multiplies* them with its initial potential, $\psi_i$
3. *Sums out* one or more variables, $\mathbf{C}_i\setminus\mathbf{S}_{i,j}$
4. *Sends* this message/factor, $\delta_{i\rightarrow j}$ to another clique

$$\delta_{i\rightarrow j}=\sum_{\mathbf{C}_i\setminus\mathbf{S}_{i,j}}
\psi_i\cdot\prod_{k\in\text{Nb}_i\setminus\{j\}}\delta_{k\rightarrow i}$$

For root clique $\mathbf{C}_r$, its *beliefs* is the factor defined by
$$\beta_r(\mathbf{C}_r)=\psi_r\cdot\prod_{k\in\text{Nb}_r}
\delta_{k\rightarrow r}$$

</font>

## SP message passing: Correctness

<font size="5">

Let $\mathcal{T}$ be a clique tree that satisfies the family-preservation and
running intersection property.

<prp>
If $X$ is eliminated when a message is sent from $\mathbf{C}_i$ to
$\mathbf{C}_j$, then $X$ does not appear anywhere in the tree on the
$\mathbf{C}_j$ side of the edge $(i-j)$.
</prp>

<thm>
Let $\delta_{i\rightarrow j}$ be a message from $\mathbf{C}_i$ to
$\mathbf{C}_j$. Then
$$\delta_{i\rightarrow j}(\mathbf{S}_{i,j})=
\sum_{\mathcal{V}_{\prec (i\rightarrow j)}}
\prod_{\phi\in\mathcal{F}_{\prec (i\rightarrow j)}}\phi$$
</thm>
where $\mathcal{F}_{\prec (i\rightarrow j)}$ is the set of factors in cliques on
the $\mathbf{C}_i$-side of an edge, and $\mathcal{V}_{\prec (i\rightarrow j)}$
is the set of variables that appear on the $\mathbf{C}_i$-side but are not in
$\mathbf{S}_{i,j}$.

- $\beta_r(\mathbf{C}_r)=\sum_{\mathcal{X}\setminus\mathbf{C}_r}
\tilde{P}_\Phi(\mathcal{X})=\tilde{P}_\Phi(\mathbf{C}_r)$

</font>

## SP message passing: Applicability

<font size="5">

SP message passing on a clique tree can be used to do VE on both BNs and MNs.

- Let $\Phi$ respectively be the set of CPDs for BNs, and the set of
compatibility functions for MNs.

</font>

## SP belief propagation (BP)

<font size="5">

SP BP: Pass messages (asynchronously) until each $\mathbf{C}_i$ has received
a message from each neighboring $\mathbf{C}_k$.

<def>
Two adjacent cliques $\mathbf{C}_i$ and $\mathbf{C}_j$ are calibrated if
$$\sum_{\mathbf{C}_i\setminus\mathbf{S}_{i,j}}\beta_i(\mathbf{C}_i)=
\sum_{\mathbf{C}_j\setminus\mathbf{S}_{i,j}}\beta_j(\mathbf{C}_j)$$
</def>

- Clique tree $\mathcal{T}$ is calibrated if all pairs of adjacent cliques are
calibrated.
- If $\mathcal{T}$ is calibrated, we refer to $\beta_i(\mathbf{C}_i)$ as
*clique beliefs* and $\mu_{i,j}(\mathbf{S}_{i,j})=
\sum_{\mathbf{C}_i\setminus\mathbf{S}_{i,j}}\beta_i(\mathbf{C}_i)=
\sum_{\mathbf{C}_j\setminus\mathbf{S}_{i,j}}\beta_j(\mathbf{C}_j)$ as
*sepset beliefs*.
- SP BP terminates $\Rightarrow$ $\mathcal{T}$ is calibrated.

</font>

## Calibrated clique trees

At calibration

$$\begin{equation*}
\begin{split}
\beta_i &= \psi_i\cdot\prod_{k\in\text{Nb}_i}\delta_{k\rightarrow i} \\
\mu_{i,j} &= \delta_{j\rightarrow i}\delta_{i\rightarrow j}
\end{split}
\end{equation*}$$

<prp>
At convergence of SP BP, we have that
$$\tilde{P}_\Phi(\mathcal{X})=
\frac{\prod_{i\in\mathcal{V}_\mathcal{T}}\beta_i(\mathbf{C}_i)}{
\prod_{(i-j)\in\mathcal{E}_\mathcal{T}}\mu_{i,j}(\mathbf{S}_{i,j})}$$
</prp>
$\tilde{P}_\Phi(\mathcal{X})$ reparameterized in terms of the $\beta_i$s and
$\mu_{i,j}$s (i.e. clique and sepset beliefs, or the clique marginals).

## Calibrated clique trees

<font size="5">

<def>
The *measure induced by a calibrated tree* $\mathcal{T}$ is
$$\mathcal{Q}_\mathcal{T}=
\frac{\prod_{i\in\mathcal{V}_\mathcal{T}}\beta_i(\mathbf{C}_i)}{
\prod_{(i-j)\in\mathcal{E}_\mathcal{T}}\mu_{i,j}(\mathbf{S}_{i,j})}$$
</def>

For a set of calibrated potentials derived from SP BP, the following hold

- $\mathcal{Q}_\mathcal{T}=\tilde{P}_\Phi(\mathcal{X})$
- $\beta_i(\mathbf{C}_i)=\sum_{\mathcal{X}\setminus\mathbf{C}_i}
\tilde{P}_\Phi(\mathcal{X})=\tilde{P}_\Phi(\mathbf{C}_i)$

<thm>
Let $\beta_i$ be a set of calibrated potentials for clique tree $\mathcal{T}$.
$\tilde{P}_\Phi(\mathcal{X})\propto\mathcal{Q}_\mathcal{T}$ iff for each
$i\in\mathcal{V}_\mathcal{T}$,
$\beta_i(\mathbf{C}_i)\propto\tilde{P}_\Phi(\mathbf{C}_i)$.
</thm>

</font>

## Belief-update (BU) message passing

<font size="5">

Also known as the *Lauritzen-Spiegelhalter algorithm*.

Each message passing step modifies the $\beta_i$s and $\mu_{i,j}$s while
maintaining $\mathcal{Q}_\mathcal{T}=\tilde{P}_\Phi(\mathcal{X})$ as an
invariant.

- In addition to the "sum" and "product" operations, *factor division* needs to
be defined.

In contrast, SP message passing focuses on receiving $\delta_{k\rightarrow i}$s
and sending $\delta_{i\rightarrow j}$s. $\beta_i$ is computed once all
$\delta_{k\rightarrow i}$s have been received.

</font>

## BU message passing: Steps

<font size="5">

Each clique, $\mathbf{C}_i$

1. *Receives* message, $\sigma_{k\rightarrow i}/\mu_{i,k}$ through edge $(i-k)$.
2. *Updates* its belief $\beta_i$ by *multiplying* it with
$\sigma_{k\rightarrow i}/\mu_{i,k}$
3. *Sums* out one or more variables, $\mathbf{C}_i\setminus\mathbf{S}_{i,j}$
from the updated $\beta_i$
4. *Sends* this message, $\sigma_{i\rightarrow j}$ towards neighbor clique,
$\mathbf{C}_j$

Each edge, $(i-j)$

1. *Divides* a message, $\sigma_{i\rightarrow j}$ that crosses it by its
belief, $\mu_{i,j}$. $\sigma_{i\rightarrow j}/\mu_{i,j}$ is sent to the 
destination clique, $\mathbf{C}_j$
2. *Updates* its belief $\mu_{i,j}=\sigma_{i\rightarrow j}$

BU MP converges $\Rightarrow$ $\mathcal{T}$ is calibrated.

</font>

## Equivalence of SP/BU message passing

<font size="5">

<thm>
Consider a set of SP initial potentials $\{\psi_i\mid i\in
\mathcal{V}_\mathcal{T}\}$ and messages $\{\delta_{i\rightarrow j},
\delta_{j\rightarrow i}\mid (i-j)\in\mathcal{E}_\mathcal{T}\}$, and a set of
BU beliefs $\{\beta_i\mid i\in\mathcal{V}_\mathcal{T}\}$ and messages
$\{\mu_{i,j}\mid (i-j)\in\mathcal{E}_\mathcal{T}\}$. Suppose equations
$$\begin{equation*}
\begin{split}
\beta_i &= \psi_i\prod_{k\in\text{Nb}_i}\delta_{k\rightarrow i} \\
\mu_{i,j} &= \delta_{j\rightarrow i}\delta_{i\rightarrow j}
\end{split}
\end{equation*}$$
hold. Then for any $(i-j)\in\mathcal{T}$, the updated SP messages after an
application of $\text{SP-Message}(i,j)$ and the updated BU beliefs after an
application of $\text{BU-Message}(i,j)$ continue to satisfy these equations.
</thm>

- We do not assume $\delta_{i\rightarrow j}=\sum_{\mathbf{C}_i\setminus
\mathbf{S}_{i,j}}\psi_i\prod_{k\in\text{Nb}_i\setminus\{j\}}
\delta_{k\rightarrow i}$, or anything specific about how the initial messages
were computed!

</font>

## Equivalence of SP/BU MP: Implications

<font size="5">

<cor>
The clique tree invariant (i.e.
$\mathcal{Q}_\mathcal{T}=\tilde{P}_\Phi(\mathcal{X})$) holds initially for BU
MP, and for each subsequent MP step.
</cor>

- If clique/sepset beliefs can be factorized according to the two equations on
the previous slide, then $\mathcal{Q}_\mathcal{T}=
\tilde{P}_\Phi(\mathcal{X})$ holds.
- After each BU step, the updated beliefs can be factorized accordingly.
- Since the initial beliefs can also be factorized accordingly, the invariant
must hold throughout the algorithm's run.

</font>

## Constructing a clique tree

<font size="5">

1. An execution of VE can be associated with a clique tree (i.e. cluster tree +
running intersection property).

<cor>
Let $\mathcal{T}$ be a clique tree induced by VE using ordering $\prec$.
$\mathbf{C}_i\in\mathcal{V}_\mathcal{T}$ iff $\mathbf{C}_i$ is a clique in the
induced graph $\mathcal{I}_{\Phi,\prec}$.
</cor>

- This motivates the term *clique* tree.
- It is standard to reduce $\mathcal{T}$ so that each $\mathbf{C}_i\in
\mathcal{V}_\mathcal{T}$ is a maximal clique in $\mathcal{I}_{\Phi,\prec}$.

<thm>
Let $\mathcal{T}$ be a clique tree induced by VE using ordering $\prec$. There
exists a clique tree $\mathcal{T}'$ such that $\mathcal{V}_\mathcal{T}'\subseteq
\mathcal{V}_\mathcal{T}$ and every $\mathcal{V}_\mathcal{T}'$ is the set of
maximal cliques in $\mathcal{I}_{\Phi,\prec}$.
</thm>

</font>

## Constructing a clique tree

<font size="5">

Every chordal graph has a clique tree, and any clique tree can be used for
inference.

$$\Phi\rightarrow\mathcal{H}_\Phi\rightarrow\mathcal{H}^*
\rightarrow\mathcal{T}$$

<def>
The process of constructing a chordal graph that subsumes an existing graph is
called *triangulation*.
</def>

Finding a minimum triangulation (i.e. the largest clique in the resulting
chordal graph has minimum size) is $\mathcal{NP}$-hard.

Finding the maximal cliques in a graph is $\mathcal{NP}$-hard.

We still need to determine the edges in the clique tree after identifying the
maximal cliques.

</font>